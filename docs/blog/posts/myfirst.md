---
date:
  created: 2026-01-06
---

# 世界是一个巨大的外部调用

等待异步调用是没有意义的
<!-- more -->

其实世界是一个巨大的外部调用，考试是输入答案，外部调用阅卷者输出分数；给别人分配任务是输入背景和要求，外部调用组员输出任务结果；找工作是输入简历，外部调用App输出面试邀请。所以和AI的提示词工程一样，你的输入越精致和完整，输出就可能越好，但是结果一般仍然是随机不可控的，这是一个黑盒测试。

可惜，大部分的外部调用使用的都是非确定性算法，同样的输入，因为人和内部噪声的原因，可能得到不同的输出。（人是系统中最不安全和最不稳定的因素，社会工程学破解总比暴力破解高效）只有考试可以看作一个幂等函数，对于同样的输入，我们总能得到一样的输出。

对于这样的外部调用，我们只能像给ai写提示词一样优化自己的输入，比如分配任务时，如果只输入“写个报告”，这就是一个低质量 Prompt，输出结果往往也是随机且不可控的。如果你输入背景、目标、参考案例和截止时间这样精致的 Prompt，输出结果的确定性就会大大提高，然而不要过多的期望会返回你想要的结果。

如果把他们写作一个接口，比如找工作时输入参数是

- `resume`: 结构化数据，包含你的过去轨迹
- `referral_token`: （可选）内推码，可大幅降低请求延迟并增加响应成功率

然而这是一个极度不稳定的异步接口。系统会根据当前并发量（竞争人数）和节点负载（公司预算）进行随机丢包（泡池子la ji tong去吧）。哪怕你的 Prompt 写得再精致，如果目标服务器处于 `503 Service Unavailable`（裁员/冻结）状态，你也只会收到空结果。

更具体的说，世界是一个巨大的外部且异步的调用。等待异步调用的结果是没有意义的，只有同步才需要等待。正确的做法是发送异步调用之后就转去执行自己本地的代码，只有真正要用到结果的时候再进行催促和等待。

焦虑源于等待异步调用的Callback，之所以很多人感到痛苦，是因为他们在潜意识里把世界当成了单线程同步调用。他们发出一个请求后，代码就停在那一行死等 `Response`，导致整个生命进程 CPU 占用率 100%（精神内耗），却不产生任何实际输出。

在高效的异步编程中，发出调用后，我们会立即释放线程去处理其他任务。在计算机科学中，只有当你遇到了强依赖时，才不得不进入 `await` 状态。

- 真依赖： 你需要拿到考试分数才能申请下一阶段的学位。
- 伪依赖：“等他回我信息了我才有心情干活”。这种属于逻辑耦合过紧。在重构时，应该把“心情”和“他人的返回”解耦。很多人的错误在于将 `system_mood`（系统心情）全局变量挂载到了外部接口的 `onSuccess` 回调里。真正的健壮架构应当将 `mood_state` 维护在本地闭环中。 无论外部接口返回的是 `200 OK` 还是 `500 Internal Server Error`，本地的主循环都不该因此挂起或崩溃。

当然，有时候就算你做的很好，外部调用的结果也可能不如人愿，这个时候就应该发挥软件工程的精神，责怪外部团队给的是什么狗史接口。