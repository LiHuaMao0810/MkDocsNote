# 测试计划



这个 PPT 实际上把测试计划拆解成了：**明确目标、找对路径、攒齐资源、设定指标**。

**三大支柱 (S.S.R)**：

- **Scope（范围）**：解决“测什么”和“不测什么”的问题。
- **Schedule（路径）**：设定时间线，解决“什么时候测”的问题。
- **reSource（资源）**：解决“谁来测、用什么测”的问题。

---

### 设定范围

**需求工程**：所谓需求，就是为开发或阶段制定的目标。需求分析是为了解决“不同的人对同一句话理解不同”的问题。

**QA 的核心任务**：

- 检查每个功能是否都有合适的**测试方法/策略**。
- 确保团队对需求的理解在同一个**基准线 (Baseline)** 上。
- 编写**测试用例大纲 (Test Case Inventory)**。

在测试计划中，**确定范围（Scope）** 绝不仅仅是划定一个测试边界，它是一个**目标**与**条件**不断博弈和迭代的过程 。

---

**明确“目标”与“条件”的因果关系**

PPT 提出了一个非常深刻的观点：范围是由你拥有的**初始条件**和你想要达到的**最终目标**共同决定的。

**设定条件（你手里有什么）**：

- **商业与需求**：商业模式、总体的功能需求与非功能需求（性能、质量等）。
- **资源储备**：现有的人力资源、基础设施（服务器、测试设备）、技术储备以及预算金额。
- **时间**：项目的开始时间。
- **核心逻辑**：你需要好好看看手上已经有什么，还缺什么。

**设定目标（你想要什么）**：

- **愿景与功能**：你希望实现的核心理念、功能模块和技术指标。
- **能力与成本**：团队的组织能力、运维的可靠性、技术的先进性以及最终的结束时间。

> [!example]
>
> **初始条件**：老板只给了 3 个人，两周时间，预算 5 万块。
>
> **目标**：要做一个能点餐、能付钱、能送货的外卖 APP。
>
> **博弈结果（确定范围）**：因为人少时间紧，我们的**范围**定为：只测“下单流程”和“微信支付”。至于“会员积分”、“评价系统”，虽然也是需求，但这次**不在测试范围**内。

---

**应对需求变更（目标偏离）**

在实际操作中，计划往往赶不上变化。PPT 指出，范围是会发生偏离的：

- **目标变更**：当实现的目标与计划目标出现差异时，就发生了变更。
- **条件变更**：当现实条件（如预算缩水或人员离职）与假设条件不同时，范围也必须调整。
- **核心结论**：**需求变更本质上就是目标的变更**。测试范围必须随之动态调整，否则测试目标就会失效。

---

**QA 在需求分析阶段的“三问”**

为了确保范围设定的科学性，QA 在需求阶段需要通过以下三个关键问题来卡点 ：

**可测性（Testability）：能不能测？怎么测？**

检查需求是否具体到可以被验证，并提前想好招数 。

> [!example]
>
> **反面例子：** 需求文档写着“APP 支付响应要快” 。
>
> **QA 的挑战：** “快”是多少？没法测！
>
> **正面改进：** 需求改为“从点击支付到跳转成功页面，耗时不得超过 2 秒” 。
>
> **QA 的动作：**
>
> **策略：** 我们要用自动化脚本模拟 100 个人同时支付，看响应时间 。
>
> **用例大纲（Test Case Inventory）：** 提前列出清单：1. 正常支付；2. 余额不足支付；3. 断网支付 。

**基准线（Baseline）：大家想的是不是一回事？**

确保产品经理（需求方）、开发（实现方）和测试（验证方）对同一个功能的认知是完全同步的 。

> [!example] 关于“取消订单”功能。
>
> **产品经理：** 觉得用户随时都能取消订单 。
>
> **开发：** 觉得只要商家没接单，用户就能取消订单 。
>
> **测试（QA）：** 问：“如果商家已经做好了菜，但还没骑手取餐，能不能取消？如果取消，钱退多少？” 。
>
> **QA 的目的：** 就像那个“秋千图”，QA 的作用是把所有人拉到会议室，定死规则：订单支付 5 分钟内且商家未接单可全额退款。这个确定的规则就是 **Baseline** 。

 **度量标准：测到什么程度能“放行”？**

提前设定好评估方法和通过的门槛（阈值），这就是**准出标准（Exit Criteria, EC）** 。

> [!example]
>
> **评估方法：** 我们不仅看 Bug 数量，还要看“代码覆盖率”和“缺陷密度” 。
>
> **阈值（门槛）设定：**
>
> 1. **Bug 要求：** P0（闪退、无法支付）级别的 Bug 必须为 0 。
> 2. **代码要求：** 核心支付代码的**圈复杂度**不能超过 10（即逻辑不能太乱） 。
> 3. **覆盖率要求：** 测试用例必须 100% 全部跑完 。
>
> **QA 的动作：** 如果最后测试完，发现还有一个不痛不痒的文字错别字（P3 级 Bug），按照预设的阈值，这是允许通过的，APP 可以上线 。

---

### 设定路径

- **准备期工作**：包括商业模型建立、环境搭建（运行环境、执行环境、基础设施环境）。
- **逐步细化**：制定计划是一个“悖论”，因为计划本身就是计划的一部分，需要随着需求的清晰不断细化。
- **迭代筹划**：在 Sprint（冲刺）开始前，QA 需参与筹划，确定评估方法和阈值。

在搞定了“范围”之后，接下来的核心任务是**设定路径（Schedule）**。这不仅仅是画一个时间轴，更是要定下一套可落地的**软件开发流程（SDP）**。

---

**准备期的“基建”三要素**

在正式开始测之前，路径的起点是环境搭建。PPT 强调了三个必须搞定的环境：

- **运行环境（OP）**：软件最终运行在哪里？
- **执行环境（SA）**：测试代码和脚本在哪里跑？
- **支持环境（Infra）**：底层的基础设施是否稳固？
- **核心逻辑**：路径的第一步不是写代码，而是先把这三个环境攒齐。

> [!example] 
>
> **环境准备**：测试前，你得先找老板要几台 iPhone 和安卓手机（运行环境），还得在公司服务器上装好自动化脚本工具（执行环境）。
>
> **准入标准（AC）**：开发说写完了，测试说：“等一下！代码必须通过自动化扫描，且没有严重 Bug 才能提测。”
>
> **准出标准（EC）**：测试测完了，说：“所有核心流程（点单支付）通过率 100%，剩下的轻微 Bug 不影响使用，可以发布了。”

---

**计划的两个“悖论”**

这两个悖论解释了为什么你的预估总是准不了，因为**“未知”**是项目的常态。

**悖论 1：制定计划也是计划的一部分**

你不需要等到所有细节都完美了才开始。计划是一个“动态调整”的过程，随着工作的推进，模糊的地方会变得清晰。

> [!example] 
>
> 你打算花 2 天写“支付功能测试计划”。但你不能这两天啥都不干只写文档。你得先花半天了解微信支付的接口（动工），在了解过程中你才发现“原来退款流程很复杂”，于是你把原本预估的 5 天测试时间改成了 8 天。**这就是在执行中细化计划。**

**悖论 2：先需求分析还是先计划？**

两者是互为因果的“鸡生蛋”关系，通常是同步进行的。

> [!example] 
>
> 老板问你点单功能要测多久。你现在只有一句话需求（模糊需求），你凭经验说“大概 3 天”（初步计划）。然后你开始研究具体的退单逻辑（需求分析），发现逻辑非常绕，你立刻修正计划说：“不行，得测 5 天”（修正计划）。**你不能等分析完才做计划，因为老板等不及；你也不能只抱死第一版计划，因为那不科学。**

---

**敏捷路径下的 Sprint 筹划**

针对预估不准的“痼疾”，敏捷开发用一种“小步快跑”的策略来对冲风险。

**平行世界：开发和测试在 Sprint 中是平行的**

测试不是等开发全部写完才开始的“最后一棒”，而是在同一个周期内同时进行的。

> [!example] 
>
> 在这个 2 周的 Sprint 里，第 1-3 天开发在写支付代码，测试也没闲着，在写测试脚本和准备测试数据；第 4 天开发写好一个模块，测试马上就测一个模块。**大家在同一个时空里跑，而不是开发跑完一万米再把棒交给测试。**

**需求分析阶段的 QA 介入：提前排雷**

在需求还没动笔写代码前，QA 就得进去看这个功能“能不能测”。

> [!example] 
>
> 产品经理说要做一个“AI 智能推荐菜品”。QA 马上问：“我怎么验证它是‘智能’的？推荐标准是什么？有没有对应的日志可以查？”如果产品经理答不上来，说明这个功能不可测，**QA 这时介入就避免了开发白写代码，减少了无效的预估。**

**基准线（Baseline）对齐：确保大家在一个频道上**

通过快速反馈，随时检查大家想的是不是一回事。

> [!example] 
>
> Sprint 第 3 天，开发做出了一个初步界面。
>
> QA 过去一看：“不对啊，我们要的是‘一键下单’，你这怎么还得点三次确认？”
>
> 开发说：“我以为确认更安全。”QA 马上纠正：“不行，需求 Baseline 是简洁，改回来。”
>
> **这种快速反馈防止了项目跑偏，让预估的时间不至于因为做错而浪费。**

---

**设定评估阈值**

在路径的每一个关键节点，都要有明确的卡点：

- **准入准出标准（AC/EC）**：明确什么时候可以开始测试，什么时候可以结束测试。
- **度量与反馈**：在路径中通过数据（如缺陷密度、进度偏差）来监控实际路径是否偏离了计划路径。



---

### 组织资源

在测试计划中，**组织资源（reSource）** 不仅仅是数人头，而是要确保你在正确的时间拥有正确的能力和工具。PPT 将资源分为五个维度，每个维度都决定了测试能不能跑通。

**人力与组织资源：建立“全功能”团队**

测试不应该是孤立的，需要建立一个涵盖各种角色、能独立交付功能的团队。

> [!example]
>
> 如果你要测试“外卖配送追踪”功能，你的团队里不能只有测试员（QA）。你还得能随时拉到开发员（DEV）修复地图跳转的 Bug，拉到需求分析师（BA）确认配送员状态的逻辑。如果缺了其中一个，测试发现问题后只能挂在那里，进度就卡死了。

**物理资源：获得足够的基础设施**

指测试执行所需的硬性软硬件环境。

> [!example]
>
> 你要测试 APP 在不同手机上的表现。你手里得有真实的 iPhone 15、华为手机、各种版本的安卓系统（运行环境）；同时，你还需要公司提供一套性能不错的服务器和数据库（支持环境），让你能模拟几千个订单同时生成的压力。没有这些硬件，测试只能靠脑补。

**知识资源：获得技术支持和储备**

团队是否具备解决特定技术问题的能力或文档支持。

> [!example]
>
> 外卖 APP 要接入“数字人民币”支付。如果团队里没人懂数字人民币的加密接口协议，你连测试用例都写不出来。这时你需要获得技术储备，比如查阅官方开发文档，或者请公司里的架构师来做一次技术培训。

**业务资源：多接触最终用户（End User）**

跳出代码逻辑，从真实的业务场景去理解产品。

> [!example]
>
> QA 亲自去大街上跟着外卖骑手跑一天。你会发现，骑手在烈日下看不清手机屏幕、戴着手套很难点中“确认送达”按钮。这种“业务资源”能让你发现那些关在办公室里永远测不出来的交互 Bug，从而改进测试用例。

**管理资源：获得老板的重视**

确保质量工作在公司层面有话语权和资源倾斜。

> [!example]
>
> 项目临近上线，开发进度延期，项目经理说：“测试别测太细了，先上线再说。”这时候，如果你拥有“管理资源”（比如老板支持“质量第一”），你就有底气说：“不行，核心支付流程还没跑通，必须延期上线修复。”老板的重视就是你卡住质量标准的腰杆。

在实际的迭代中，这些资源是交织在一起的。QA 在写文档、测功能的同时，也在帮运维（OP）部署、帮 PM 跟踪进度、帮 BA 完善需求。这就是 PPT 提到的“正常向”提交团队的常态。

---

### 软件度量

软件度量与指标是软件工程中用于量化开发过程和产品质量的方法，旨在通过数据改进流程并辅助决策。

**产品规模度量：代码行数（LOC）与功能点（FP）**

通过统计源代码的总行数或根据用户功能需求评估软件大小，以此作为衡量工作量和复杂度的基础。

> [!example]
>
> 在外卖 APP 迭代中，本月新增了“红包雨”功能。通过度量发现该功能新增了 2000 行代码（LOC），涉及 5 个功能点（FP）。如果下个月要开发类似的“转盘抽奖”，管理者就可以参考这个数据，预估也需要投入相应的人力和时间，而不是拍脑袋决定。

**质量度量：缺陷密度（Defect Density）**

指每千行代码（KLOC）或每个功能点中发现的缺陷数量，用于评估软件的可靠性。

> [!example]
>
> 支付模块有 1000 行代码，发现了 10 个 Bug；而个人中心模块有 1000 行代码，只发现了 2 个 Bug。这意味着支付模块的缺陷密度更高，说明该部分代码质量较差或逻辑太复杂，测试人员后续需要重点对支付模块进行回归测试。

**过程度量：进度偏差（Schedule Variance）**

通过实际进度与计划进度的差异，衡量项目是否按时推进。

> [!example]
>
> 测试计划原本预定在周三完成“商家入驻”流程的测试，但到了周五还没测完。这种 2 天的进度偏差提醒项目经理：可能是需求太复杂，或者是测试环境老是崩掉。这时候就需要调整路径，或者临时增加人手。

**代码实现指标：圈复杂度（Cyclomatic Complexity）**

衡量程序内部控制流的复杂程度（独立路径的数量）。复杂度越高，代码越难理解，出 Bug 的概率越大。

> [!example]
>
> 程序员写了一个判断“配送费”的函数，里面嵌套了十几层 if-else（如果雨天、如果是会员、如果距离超过 5 公里、如果深夜...）。计算发现圈复杂度达到了 30。QA 看到这个指标后会要求重构，因为逻辑太乱，测试用例很难覆盖全，极其容易漏掉某些特殊情况下的 Bug。

**测试度量：需求可追溯性（Traceability）**

确保每一个需求点都有对应的测试用例支撑，形成从需求到用例的金字塔映射关系。

> [!example]
>
> 客户要求“支持数字人民币支付”。QA 在 Traceability 矩阵中检查发现，这个需求对应了 5 个测试用例。如果这 5 个用例都测过了，就说明这个需求点被覆盖到了；如果发现某个需求没对应任何用例，那就说明漏测了。

**测试指标：缺陷分布（瑞利分布）**

利用数学模型描述缺陷随时间产生的趋势。理想状态下，Bug 应该随测试推进先增加后减少，呈现特定的曲线。

> [!example]
>
> 在外卖 APP 开启测试的前 3 天，每天发现 20 个 Bug（上升期）；到了第 10 天，每天只能发现 1-2 个 Bug（下降期）。这符合瑞利分布。但如果到了要上线的前一天，Bug 数突然又爆发式增长，这就说明代码质量严重失控，或者引入了新的大问题，此时绝对不能放行上线。